# 操作系统 作业 14

## 1
一个进程在运行过程中读写文件，它每次只读写 1 个块(块大小为 4 KB)，并且在它运行过程中一共发出 10,000 次读请求和 3,000 次写请求，其中 60% 的请求命中文件缓存。

1. 如果文件缓存采用 write through，请问最终发到磁盘上的 I/O 请求是多少次？其中读请求和写请求分别是多少？
2. 如果文件缓存采用 write back，请问最终发到磁盘上的 I/O 请求是多少次？其中读请求和写请求分别是多少？

### 解

1. 如果文件缓存采用 write through：
   * 读请求命中文件缓存时，将不会向磁盘发出 I/O 请求。那么发到磁盘上的读请求数为：10,000 × (1 - 60%) = 4,000 次；
   * 写请求命中文件缓存时，仍然会向磁盘发出 I/O 请求。那么发到磁盘上的写请求数为：3,000 次；
   * 总计 4,000 + 3,000 = 7,000 次。

2. 如果文件缓存采用 write back：
   * 读请求命中文件缓存时，将不会向磁盘发出 I/O 请求。那么发到磁盘上的读请求数为：10,000 × (1 - 60%) = 4,000 次；
   * 无论写请求受否命中文件缓存，都会将缓存块标记为“脏”，而不立刻发出 I/O 请求。
   * 缓存中的数据总会写回到磁盘中，根据运行情况，有可能只最后写回 1 次，也可能每次写请求后都会写回（即 3000 次）；
   * 故最终发到磁盘上的 I/O 请求可能是 4,001 ~ 7000 次，读请求为 4,000 次，写请求可能为 1 ~ 3,000 次。

## 2
在有文件缓存的情况下，挂载一个 FFS 文件系统后，
1. 用户 A 打开文件“`/home/OS18/fs01.pdf`”，请问需要从磁盘上读几个块？
2. 用户 A 再次打开“`/home/OS18/fs01.pdf`”，请问需要从磁盘上读几个块？
3. 用户 B 打开“`/home/OS18/fs01.pdf`”，请问需要从磁盘上读几个块？
4. 用户 C 打开“`/home/OS18/fs03.pdf`”，请问需要从磁盘上读几个块？

假设所有目录和文件只一个块。

### 解
1. 总共需要从磁盘上读 8 个块：
   * 读根目录的 i-node 和它的第一块，需要读 2 个块；
   * 读 `home` 目录的 i-node 和它的第一块，需要读 2 个块；
   * 读 `OS18` 目录的 i-node 和它的第一块，需要读 2 个块；
   * 读 `fs01.pdf` 文件的 i-node 和它的第一块，需要读 2 个块；
2. 不需要从磁盘上读块，因为第一次访问 `/home/OS18/fs01.pdf` 已经将要读取的所有磁盘块都加载到了文件缓存中。
3. 不需要从磁盘上读块，因为用户 A 第一次访问 `/home/OS18/fs01.pdf` 已经将要读取的所有磁盘块都加载到了文件缓存中，文件缓存对多用户是共享的。
4. 需要从磁盘上读 2 个块：
   * 根目录、`home` 目录、`OS18` 目录的 i-node 和第一块都在文件缓存中，不需要从磁盘上读块；
   * 读 `fs03.pdf` 文件的 i-node 和它的第一块，需要读 2 个块。

## 3
假设文件系统采用 FFS，块大小为 4KB。执行下面代码:
```c
#define MAX (1000)
char buf[MAX];
int fd = open("tmpfile", O_CREAT|O_TRUNC|O_RDWR, 0666);
int n = 0, i = 0;

if (fd <0) {
    perror("open");
    exit(-1);
}

for (int i = 0; i < MAX; i++) {
    bzero(buf, sizeof(buf));
    sprintf(buf, "%3d\n", i);
    n = write(fd, buf, strlen(buf));
    printf("len=%d\n", strlen(buf));
    if (n != strlen(buf)) {
        perror("write");
        printf("length=%d, buf=[%s]", strlen(buf), buf);
    }
}

close(fd);
```

1. 请问这段代码执行成功后，`tmpfile` 的大小是多少字节？
2. 在没有文件缓存的情况下，总共写几次磁盘，每次多少字节？
3. 在有文件缓存的情况下，总共写几次磁盘，每次写多少字节？

### 解
1. 代码成功执行后，`tmpfile` 的大小是 4000 字节。每次向文件写入四个字节（3 字节数字 ASCII，1 字节换行符），总计重复 1000 次。程序实际运行结果如下：
   ```
   $ ./a.out
   $ wc -c tmpfile 
   4000 tmpfile
   ```
2. 在没有文件缓存的情况下，意味着每次写请求都要实际写磁盘。同时，在关闭文件时需要写一次 i-node，那么，总共写 1001 次磁盘，前 1000 次每次写 4 个字节，最后一次写 4096 字节。
3. 在有文件缓存的情况下，意味着不一定每次都需要实际写磁盘。`tmpfile` 文件的大小不超过 4 KB，意味着只有关闭文件时需要写入脏数据。那么总共写 2 次磁盘，每次写 4096 字节。

## 4
在有文件缓存的情况下，在一个 FFS 文件系统中创建一个“`/home/OS18/fs03.pdf`”，需要写几个块？写哪几个块？如果在任意时刻发生宕机，会岀现哪些不一致？请详细列出所有不一致的情况。

### 解
需要写 4 个块：
* i-node Bitmap；
* 文件 `fs03.pdf` 的 i-node；
* 目录 `OS18` 含目录项 `fs03.pdf` 的目录块；
* 目录 `OS18` 的 i-node。

这 4 个块在宕机时任意一个块都有可能没有写回，有如下 16 中情况：（√ 表示写回，× 表示没有写回）
|#|i-node<br>Bitmap| `fs03.pdf` <br>的 i-node | `OS18` <br>的目录块 |`OS18` <br>的 i-node|情况说明|
|:-:|:-:|:-:|:-:|:-:|:-|
|0|√|√|√|√|正常：新建文件成功
|1|√|√|√|×|FS 不一致：目录项与目录 i-node 不对应
|2|√|√|×|√|FS 不一致：目录项与目录 i-node 不对应
|3|√|√|×|×|FS 不一致：有 i-node，没有目录项
|4|√|×|√|√|FS 不一致：有目录项，没有 i-node
|5|√|×|√|×|FS 不一致：有目录项，没有 i-node，亦与目录 i-node 不对应
|6|√|×|×|√|FS 不一致：目录 i-node 与目录项不对应
|7|√|×|×|×|FS 不一致：没有 i-node，也没有目录项
|8|×|√|√|√|FS 不一致：Bitmap 中没有记录 i-node
|9|×|√|√|×|FS 不一致：Bitmap 中没有记录 i-node，目录项与目录 i-node 不对应
|a|×|√|×|√|FS 不一致：Bitmap 中没有记录 i-node，目录项与目录 i-node 不对应
|b|×|√|×|×|FS 不一致：Bitmap 中没有记录 i-node，没有目录项
|c|×|×|√|√|FS 不一致：没有 i-node，但有目录项
|d|×|×|√|×|FS 不一致：没有 i-node，但有目录项，且目录项与目录 i-node 不对应
|e|×|×|×|√|FS 不一致：目录 i-node 与目录项不对应。
|f|×|×|×|×|正常：完全没有新建文件成功


## 5
磁盘上有一个长度为 20 KB 的文件 A，如果一个进程打开文件 A，并调用 write 一次性向文件 A 的块 0 和块 1 写入新数据。假设有文件缓存，宕机可能发生在任意时刻。
1. 如果文件系统采用数据日志，宕机恢复后，文件 A 的内容是什么？分不同情况讨论（在什么情况下，文件 A 的内容是什么）。
2. 如果文件系统采用元数据日志，并且采用一致性修改，宕机恢复后，文件 A 的内容是什么？分不同情况讨论（在什么情况下，文件 A 的内容是什么）。

### 解

需要写回 2 个块：文件 i-node，文件块 0，文件块 1。

如果文件系统采用数据日志，那么包含下面这些步骤：
1. 开始写日志
2. 写日志（写块 0）
3. 写日志（写块 1）
4. 写日志（修改 i-node）
5. 提交日志
6. 写块 0
7. 写块 1
8. 写 i-node
9. 清除日志

那么有下面几种宕机情况：
* 在步骤 1 前宕机，由于日志没有提交，那么文件 A 的内容（包括块 0 和块 1）为旧内容；
* 在步骤 2 前宕机，由于日志没有提交，那么文件 A 的内容（包括块 0 和块 1）为旧内容；
* 在步骤 3 前宕机，由于日志没有提交，那么文件 A 的内容（包括块 0 和块 1）为旧内容；
* 在步骤 4 前宕机，由于日志没有提交，那么文件 A 的内容（包括块 0 和块 1）为旧内容；
* 在步骤 5 前宕机，由于日志没有提交，那么文件 A 的内容（包括块 0 和块 1）为旧内容；
* 在步骤 6 前宕机，由于日志已经提交了，那么文件 A 的内容（包括块 0 和块 1）为新内容；
* 在步骤 7 前宕机，由于日志已经提交了，那么文件 A 的内容（包括块 0 和块 1）为新内容；
* 在步骤 8 前宕机，由于日志已经提交了，那么文件 A 的内容（包括块 0 和块 1）为新内容；
* 在步骤 9 前宕机，由于日志已经提交了，那么文件 A 的内容（包括块 0 和块 1）为新内容；
* 在步骤 9 后宕机，由于日志已经被清除了，那么文件 A 的内容（包括块 0 和块 1）为新内容。


如果文件系统采用元数据日志，那么包含下面这些步骤：
1. 写块 0
2. 写块 1
3. 开始写日志
4. 写日志（修改 i-node）
5. 提交日志
6. 写 i-node
7. 清除日志

那么有下面几种宕机情况：
* 在步骤 1 前宕机，块 0 和块 1 均为旧内容，但 i-node 未更新；
* 在步骤 2 前宕机，块 0 为新内容，块 1 为旧内容，但 i-node 未更新；
* 在步骤 3 前宕机，块 0 和块 1 均为新内容，但 i-node 未更新；
* 在步骤 4 前宕机，块 0 和块 1 均为新内容，但 i-node 未更新；
* 在步骤 5 前宕机，块 0 和块 1 均为新内容，但 i-node 未更新；
* 在步骤 6 前宕机，块 0 和块 1 均为新内容，且 i-node 已更新；
* 在步骤 6 前宕机，块 0 和块 1 均为新内容，且 i-node 已更新；
* 在步骤 7 后宕机，块 0 和块 1 均为新内容，且 i-node 已更新。

## 6
LFS 的 imap 采用类似数组的结构，下标是 ino，每项保存 i-node 的磁盘地址，例如，`imap[k]` 记录 ino 为 `k` 的 i-node 的磁盘地址。假设一个 LFS 的块大小为 4 KB，磁盘地址占 4 字节。如果已经分配了 500 万个 i-node，请问
1. 它的 imap 有多少个块？给出计算过程；
2. 它的 CR 有多少个块？给出计算过程；
3. 如何查 ino = 654321 的 i-node 的磁盘地址。给出查找和计算过程。

### 解

1. 计算过程如下：
   * 已经分配了 500 万个 i-node，而每个磁盘地址为 4 字节，那么总计有 5 × 10<sup>6</sup> × 4 = 2 × 10<sup>7</sup> 字节。
   * 每个块为 4 KB，即 4096 字节，那么总共有 ⌈2 × 10<sup>7</sup> / 4096⌉ = 4883 块。
2. 计算过程如下：
   * 每个 CR 包含 1024 个 imap 块的地址（4096 / 4 = 1024）。
   * 总共有 4883 块 imap，那么则有 ⌈4883 / 1024⌉ = 5 块 CR。
3. 查找和计算过程如下：
   * 计算这个 ino 对应的 `imap[k]` 记录在哪一块上：⌊654321 / 1024⌋ = 638 块（每块保存 4096 / 4 = 1024 个地址，从 0 开始计数）；
   * 由于 638 < 1024，说明这个 ino 对应的 `imap[k]` 所在的 imap 块，其地址记录在第 0 块 CR 上，是这块 CR 的第 638 块 imap；
   * 然后计算这个 ino 对应的 `imap[k]` 是这一块的第几个：654321 mod 1024 = 1009 个（从 0 开始计数）；
   * 读取 CR 第 0 块指向的第 638 块 `imap` 中的 4036 至 4039 这 4 个字节（1009 × 4 ~ 1009 × 4 + 3），得到 i-node 的磁盘地址。


## 7
一个 LFS 的块大小为 4 KB，segment 大小是 4 MB。文件块采用与 FFS 一样的多级索引，每个指向数据块的指针占 4 字节。该 LFS 中已经有一个 20MB 的文件 `foo`
1. 给出文件 `foo` 的文件块索引结构；
2. 写文件 `foo` 的第 2560 块(假设它在磁盘块 Ai 中，Ai 为磁盘逻辑块号)，需要写哪些块？给出它们写在磁盘上的顺序。需要几次 I/O；
3. 如果是 FFS（其块大小也为 4KB），写文件 foo 的第 2560 块，需要写哪些块？需要几次 I/O？
4. 如果是日志文件系统，只记录元数据日志，且日志不采用批量提交，则写文件 `foo` 的第 2560 块，需要写哪些块？需要几次 I/O？

### 解

1. `foo` 总共 20 × 1024 ÷ 4 = 5120 块，其文件块索引结构为：
   ```
   1   ------------------> Block 0
   ...                             ...
   10 -------------------> Block 9
   11 ->-- 1     --------> Block 10
        |- ...                     ...
        -- 1024  --------> Block 1033
   12 ->-- 1 -> -- 1    -> Block 1034
        |       |-                 ...
        |       |- 1024 -> Block 2057
        |- 2 -> -- 1    -> Block 2058
        |       |-                 ...
        |       -- 1024 -> Block 3081
        |- 3 -> -- 1    -> Block 3082
        |       |-                 ...
        |       -- 1024 -> Block 4105
        |- 4 -> -- 1    -> Block 4106
        |       |-                 ...
        |       |- 1014 -> Block 5119
        |       |- 1015 -> NULL
        |       |-                 ...
        |       -- 1024 -> NULL
        |- 5 -> NULL
        | ...      ...
        --1024->NULL
   13 ->NULL
   ```
2. 如果是 LFS：
   * 依次访问 CR、imap、`foo` 的 i-node（读 3 块）；
   * 根据 i-node 信息，依次读一级间址块、二级间址块，找到第 2560 块（读 2 块）；
   * 写第 2560 块以及 i-node 块（写 1 次 2 块）。
   总共需要 6 次 I/O。
3. 如果是 FFS：
   * 通过目录解析找到 `foo` 的 i-node（读 2 块）；
   * 根据 i-node 信息，依次读一级间址块、二级间址块，找到第 2560 块（读 2 块）；
   * 写第 2560 块以及 i-node 块（写 2 块）。
   总共需要 6 次 I/O。
4. 如果是元数据日志文件系统：
   * 通过目录解析找到 `foo` 的 i-node（读 2 块）；
   * 根据 i-node 信息，依次读一级间址块、二级间址块，找到第 2560 块（读 2 块）；
   * 写第 2560 块，写日志开始标记，写日志（i-node），写日志提交标记，写 i-node，清除日志（写 6 次）；
   总共需要 10 次 I/O。